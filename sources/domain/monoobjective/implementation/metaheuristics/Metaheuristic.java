package domain.monoobjective.implementation.metaheuristics;

import domain.EvaluationFunction;
import domain.util.threads.RunObjective;
import domain.monoobjective.MonoObjectiveAlgorithm;
import domain.monoobjective.MonoObjectiveSolution;
import domain.monoobjective.implementation.MatrixSolution;
import domain.operators.Reparator;
import domain.problem.ProblemInstance;
import java.util.List;
import java.util.Random;

/**
 *
 * @author cristian.erazo@cinvestav.mx
 * @param <T>
 */
public abstract class Metaheuristic<T extends MonoObjectiveSolution> implements MonoObjectiveAlgorithm<Integer[], Double> {

    protected RunObjective[] threads;
    /**
     * Random number generator
     */
    protected Random rand;
    /**
     * The number of iterations.
     */
    protected int numIterations;
    /**
     * The instance of the problem to be solved.
     */
    protected final ProblemInstance instance;
    /**
     * The objective/fitness function.
     */
    protected final EvaluationFunction<Double, T> fx;
    /**
     * *
     * The number of non-factible solutions generated by the algorithm.
     */
    protected long numNotValidSolutions;
    /**
     * The best solution found.
     */
    protected T best;
    /**
     *
     */
    protected Reparator<T> reparator;
    /**
     *
     */
    protected EvaluationFunction<Double, T>[] tFx;
    /**
     *
     */
    protected Reparator<T>[] tRep;
    /**
     *
     */
    protected ProblemInstance[] tIns;
    /**
     *
     */
    protected double avgFx;
    /**
     *
     */
    protected long it;

    protected Metaheuristic(ProblemInstance instance, EvaluationFunction<Double, T> fx, Random rand, int numIterations) {
        this.fx = fx;
        this.rand = rand;
        this.instance = instance;
        this.numIterations = numIterations;
        threads = null;
    }

    protected Metaheuristic(ProblemInstance instance, EvaluationFunction<Double, T> fx, Random rand, int numIterations, int numThreads) {
        this.fx = fx;
        this.rand = rand;
        this.instance = instance;
        this.numIterations = numIterations;
        if (numThreads > 1) {
            threads = new RunObjective[numThreads];
            tFx = new EvaluationFunction[numThreads];
            tIns = new ProblemInstance[numThreads];
            tRep = new Reparator[numThreads];
        } else {
            threads = null;
            tFx = null;
            tIns = null;
            tRep = null;
        }
    }

    public long getNumNotValidSolutions() {
        return numNotValidSolutions;
    }

    public int getNumIterations() {
        return numIterations;
    }

    protected double concurrentEvaluatePopulation(List<MatrixSolution> population) {
        avgFx = 0;
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new RunObjective(population, instance, reparator, fx, tIns, tRep, tFx, i, it);
            threads[i].start();
        }
        for (RunObjective thread : threads) {
            try {
                thread.join();
                numNotValidSolutions += thread.getNumNotValid();
                avgFx += thread.getSumObjectives();
                getThreadResults(thread);
            } catch (InterruptedException ex) {
                ex.printStackTrace(System.err);
                Thread.currentThread().interrupt();
            }
        }
        avgFx /= (double) population.size();
        return avgFx;
    }

    @Override
    public abstract MonoObjectiveSolution<Integer[], Double> run();

    protected abstract void getThreadResults(RunObjective thread);
}
